package isn.gui;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.ByteLookupTable;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.awt.image.LookupOp;
import java.awt.image.RescaleOp;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;

import javax.imageio.ImageIO;

import isn.Main;
import isn.cards.Card;

@SuppressWarnings("serial")
class ImageDrawingComponent extends Component {

	static String descs[] = {
			"Simple Copy",
	};

	int opIndex;
	private BufferedImage bi;
	int w, h;
	String img;

	public static final float[] SHARPEN3x3 = { // sharpening filter kernel
			0.f, -1.f,  0.f,
			-1.f,  5.f, -1.f,
			0.f, -1.f,  0.f
	};

	public static final float[] BLUR3x3 = {
			0.1f, 0.1f, 0.1f,    // low-pass filter kernel
			0.1f, 0.2f, 0.1f,
			0.1f, 0.1f, 0.1f
	};

	public ImageDrawingComponent(URL imageSrc) {
		try {
			bi = ImageIO.read(imageSrc);
			w = bi.getWidth(null);
			h = bi.getHeight(null);
			if (bi.getType() != BufferedImage.TYPE_INT_RGB) {
				BufferedImage bi2 = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
				Graphics big = bi2.getGraphics();
				big.drawImage(bi, 0, 0, null);
				bi = bi2;
			}
		} catch (IOException e) {
			System.out.println("Image could not be read");
		}
	}

	@Override
	public Dimension getPreferredSize() {
		return new Dimension(w, h);
	}

	static String[] getDescriptions() {
		return descs;
	}

	void setOpIndex(int i) {
		opIndex = i;
	}

	/* In this example the image is recalculated on the fly every time
	 * This makes sense where repaints are infrequent or will use a
	 * different filter/op from the last.
	 * In other cases it may make sense to "cache" the results of the
	 * operation so that unless 'opIndex' changes, drawing is always a
	 * simple copy.
	 * In such a case create the cached image and directly apply the filter
	 * to it and retain the resulting image to be repainted.
	 * The resulting image if untouched and unchanged Java 2D may potentially
	 * use hardware features to accelerate the blit.
	 */
	public void paint(Graphics g) {
		BufferedImage bi2 = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
		Graphics big = bi2.getGraphics();
		big.drawImage(bi, 0, 0, null);
		preDrawCards(Main.bj.computer.getCards(), big);
		preDrawCards(Main.bj.player.getCards(), big);

		g.drawImage(bi2, 0, 0, null);
	}

	public void preDrawCards(ArrayList<Card> cards, Graphics big){
		if(!cards.isEmpty()){
			for(int i=0;i<cards.size();i++){
				try {
					big.drawImage(ImageIO.read(cards.get(i).getImg()), w/2 + i*16, h-16, null);
					big.drawImage(ImageIO.read(cards.get(i).getType().getImg()), w/2 + i*16, h-16, null);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}